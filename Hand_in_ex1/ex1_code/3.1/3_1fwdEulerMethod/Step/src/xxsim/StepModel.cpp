/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  src\xxsim\StepModel.cpp
 *  subm:  StepModel
 *  model: Step
 *  expmt: 20-2746
 *  date:  May 29, 2015
 *  time:  6:08:11 pm
 *  user:  Universiteit Twente 
 *  from:  20-sim 4.5 Campus Licentie
 *  build: 4.5.1.5561
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>

/* 20-sim include files */
#include "xxsim/StepModel.hpp"

using namespace std;

namespace Step
{

  StepModel::StepModel()
  {
    setupComputation();
  }

  StepModel::~StepModel(void)
  {
    /* delete IO mappings */
    while(!m_inputs.empty())
    {
      IAdapter20Sim* a = m_inputs.back();
      m_inputs.pop_back();
      delete a;
    }

    while(!m_outputs.empty())
    {
      IAdapter20Sim* a = m_outputs.back();
      m_outputs.pop_back();
      delete a;
    }

    /* free memory */
    delete[] C;
    delete[] P;
    delete[] I;
    delete[] V;
    delete[] s;
    delete[] R;
    delete[] M;
    delete[] U;
    delete[] workarray;
  }

  void StepModel::setupComputation()
  {
    start_time = 0.0;
    finish_time = 0;
    step_size = 1.0;
    time = 0;
    major = true;

    number_constants = 0;
    number_parameters = 2;
    number_initialvalues = 0;
    number_variables = 2;
    number_states = 0;
    number_rates = 0;
    number_matrices = 0;
    number_unnamed = 0;

    /* the variable arrays */
    C = new XXDouble[0 + 1]; /* constants */
    P = new XXDouble[2 + 1]; /* parameters, currently only one type of parameter exists: double */
    I = new XXDouble[0 + 1]; /* initial values */
    V = new XXDouble[2 + 1]; /* variables */

    s = new XXDouble[0 + 1]; /* states */
    R = new XXDouble[0 + 1]; /* rates (or new states) */
    M = new XXMatrix[0 + 1]; /* matrices */
    U = new XXDouble[0 + 1]; /* unnamed */
    workarray = new XXDouble[0 + 1];
  }

  bool StepModel::initializeComputation()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    initialize = true;
    //CONSTANTS
    

    //PARAMETERS
    	P[0] = 1.0;		/* amplitude */
	P[1] = 2.0;		/* start_time {s} */


    //INITIAL VALUES
    

    //MATRICES
    

    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    //STATES - do NOT move this line up!
    

    /* end of initialization phase */
    initialize = false;
    return initialize;
  }

  void StepModel::CopyInputsToVariables()
  {
    for(unsigned int i = 0; i < m_inputs.size(); ++i)
    {
      m_inputs[i]->copyVariableToXXVariable();
    }
  }

  void StepModel::CopyVariablesToOutputs()
  {
    for(unsigned int i = 0; i < m_outputs.size(); ++i)
    {
      m_outputs[i]->copyXXVariableToVariable();
    }
  }

  void StepModel::start()
  {
    initializeComputation();

    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void StepModel::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
     and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void StepModel::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  /* This function calculates the initial equations of the model.
   * These equations are calculated before anything else
   */
  inline void StepModel::CalculateInitial (void)
  {
    
  }

  /* This function calculates the static equations of the model.
   * These equations are only dependent from parameters and constants
   */
  inline void StepModel::CalculateStatic (void)
  {
    
  }

  /* This function calculates the input equations of the model.
   * These equations are dynamic equations that must not change
   * in calls from the integration method (like random and delay).
   */
  inline void StepModel::CalculateInput (void)
  {
    
  }

  /* This function calculates the dynamic equations of the model.
   * These equations are called from the integration method
   * to calculate the new model rates (that are then integrated).
   */
  inline void StepModel::CalculateDynamic (void)
  {
    	/* output = amplitude * step (start_time); */
	V[0] = P[0] * XXStep (P[1], time);

  }

  /* This function calculates the output equations of the model.
   * These equations are not needed for calculation of the rates
   * and are kept separate to make the dynamic set of equations smaller.
   * These dynamic equations are called often more than one time for each
   * integration step that is taken. This makes model computation much faster.
   */
  inline void StepModel::CalculateOutput (void)
  {
    	/* change = timeevent (start_time); */
	V[1] = XXTimeEvent (P[1], 0);

      }

  /* This function calculates the final equations of the model.
   * These equations are calculated after all the calculations
   * are performed
   */
  inline void StepModel::CalculateFinal (void)
  {
    
  }

}

