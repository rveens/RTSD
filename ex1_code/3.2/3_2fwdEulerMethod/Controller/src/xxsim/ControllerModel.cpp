/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  src\xxsim\ControllerModel.cpp
 *  subm:  ControllerModel
 *  model: Controller
 *  expmt: 20-2746
 *  date:  May 29, 2015
 *  time:  6:04:14 pm
 *  user:  Universiteit Twente 
 *  from:  20-sim 4.5 Campus Licentie
 *  build: 4.5.1.5561
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>

/* 20-sim include files */
#include "xxsim/ControllerModel.hpp"

using namespace std;

namespace Controller
{

  ControllerModel::ControllerModel()
  {
    setupComputation();
  }

  ControllerModel::~ControllerModel(void)
  {
    /* delete IO mappings */
    while(!m_inputs.empty())
    {
      IAdapter20Sim* a = m_inputs.back();
      m_inputs.pop_back();
      delete a;
    }

    while(!m_outputs.empty())
    {
      IAdapter20Sim* a = m_outputs.back();
      m_outputs.pop_back();
      delete a;
    }

    /* free memory */
    delete[] C;
    delete[] P;
    delete[] I;
    delete[] V;
    delete[] s;
    delete[] R;
    delete[] M;
    delete[] U;
    delete[] workarray;
  }

  void ControllerModel::setupComputation()
  {
    start_time = 0.0;
    finish_time = 0;
    step_size = 1.0;
    time = 0;
    major = true;

    number_constants = 0;
    number_parameters = 3;
    number_initialvalues = 0;
    number_variables = 4;
    number_states = 0;
    number_rates = 0;
    number_matrices = 0;
    number_unnamed = 0;

    /* the variable arrays */
    C = new XXDouble[0 + 1]; /* constants */
    P = new XXDouble[3 + 1]; /* parameters, currently only one type of parameter exists: double */
    I = new XXDouble[0 + 1]; /* initial values */
    V = new XXDouble[4 + 1]; /* variables */

    s = new XXDouble[0 + 1]; /* states */
    R = new XXDouble[0 + 1]; /* rates (or new states) */
    M = new XXMatrix[0 + 1]; /* matrices */
    U = new XXDouble[0 + 1]; /* unnamed */
    workarray = new XXDouble[0 + 1];
  }

  bool ControllerModel::initializeComputation()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    initialize = true;
    //CONSTANTS
    

    //PARAMETERS
    	P[0] = 1.0;		/* K {} */
	P[1] = -0.3;		/* a {} */
	P[2] = 1.0;		/* b {} */


    //INITIAL VALUES
    

    //MATRICES
    

    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    //STATES - do NOT move this line up!
    

    /* end of initialization phase */
    initialize = false;
    return initialize;
  }

  void ControllerModel::CopyInputsToVariables()
  {
    for(unsigned int i = 0; i < m_inputs.size(); ++i)
    {
      m_inputs[i]->copyVariableToXXVariable();
    }
  }

  void ControllerModel::CopyVariablesToOutputs()
  {
    for(unsigned int i = 0; i < m_outputs.size(); ++i)
    {
      m_outputs[i]->copyXXVariableToVariable();
    }
  }

  void ControllerModel::start()
  {
    initializeComputation();

    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void ControllerModel::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
     and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void ControllerModel::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  /* This function calculates the initial equations of the model.
   * These equations are calculated before anything else
   */
  inline void ControllerModel::CalculateInitial (void)
  {
    
  }

  /* This function calculates the static equations of the model.
   * These equations are only dependent from parameters and constants
   */
  inline void ControllerModel::CalculateStatic (void)
  {
    
  }

  /* This function calculates the input equations of the model.
   * These equations are dynamic equations that must not change
   * in calls from the integration method (like random and delay).
   */
  inline void ControllerModel::CalculateInput (void)
  {
    
  }

  /* This function calculates the dynamic equations of the model.
   * These equations are called from the integration method
   * to calculate the new model rates (that are then integrated).
   */
  inline void ControllerModel::CalculateDynamic (void)
  {
    	/* dx = a * MV + b * SP; */
	V[3] = P[1] * V[1] + P[2] * V[0];

	/* output = K * dx; */
	V[2] = P[0] * V[3];

  }

  /* This function calculates the output equations of the model.
   * These equations are not needed for calculation of the rates
   * and are kept separate to make the dynamic set of equations smaller.
   * These dynamic equations are called often more than one time for each
   * integration step that is taken. This makes model computation much faster.
   */
  inline void ControllerModel::CalculateOutput (void)
  {
    
      }

  /* This function calculates the final equations of the model.
   * These equations are calculated after all the calculations
   * are performed
   */
  inline void ControllerModel::CalculateFinal (void)
  {
    
  }

}

