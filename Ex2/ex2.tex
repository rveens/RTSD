\documentclass[a4paper,twoside,11pt]{article}
\usepackage{a4wide,graphicx,fancyhdr,amsmath,amssymb,placeins}
\usepackage{listings}
\usepackage{color}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{caption,subcaption}
\usepackage{placeins}

%----------------------- Macros and Definitions --------------------------

\setlength\headheight{20pt}
\addtolength\topmargin{-10pt}
\addtolength\footskip{20pt}

\newcommand{\N}{\mathbb{N}}
\newcommand{\ch}{\mathcal{CH}}
\newcommand{\cpp}{{\tt C++} }

\newcommand{\solution}[1][todo]{\noindent{\bf Solution to Exercise #1:}}
\newcommand{\todo}[1]{{\Large\sc\textcolor{red}{#1}}}

\renewcommand{\lstlistingname}{Codeblock}
\captionsetup[lstlisting]{font={small,tt}}

\fancypagestyle{plain}{%
\fancyhf{}
\fancyhead[LO,RE]{\sffamily\bfseries\large technische universiteit eindhoven}
\fancyhead[RO,LE]{\sffamily\bfseries\large 2IW02 RTSD}
\fancyfoot[LO,RE]{\sffamily\bfseries\large department of mathematics and computer science}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RO,LE]{\sffamily\bfseries\large technische universiteit eindhoven}
\fancyhead[LO,RE]{\sffamily\bfseries\large 2IW02 RTSD}
\fancyfoot[LO,RE]{\sffamily\bfseries\large department of mathematics and computer science}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{0pt}

%-------------------------------- Title ----------------------------------

\title{\vspace{-\baselineskip}\sffamily\bfseries Exercise 2}
\author{
	Rick Veens \qquad Studentno: 0912292\\
	\texttt{r.veens@student.tue.nl}
	\and
	Huib Donkers \qquad Studentno: 0769015\\
	\texttt{h.t.donkers@student.tue.nl}
}

\date{\today}

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
backgroundcolor=\color{lbcolor},
    tabsize=4,    
%   rulecolor=,
    language=[GNU]C++,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        numbers=left,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.026,0.112,0.095},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%        \lstdefinestyle{C++}{language=C++,style=numbers}â€™.
}

% geen stomme indents bij \par
\setlength{\parindent}{0cm}

%--------------------------------- Text ----------------------------------

\begin{document}
\maketitle

\section{Timers}
\subsection{Model}
The model is shown in figure~\ref{fig:timermodel}, and code used for the first two tests in codeblock~\ref{code:timer}. The improved code used for the third test is shown in codeblock~\ref{code:timer2}. We used \texttt{octave} to parse the output as csv and perform some statistical analysis.

\begin{lstlisting}[caption=Pcode::execute, label=code:timer, language=C++]
void Pcode::execute()
{
  // protected region execute code on begin
	static struct timespec t1;


	struct timespec t2;
	struct timespec res;

	clock_gettime(CLOCK_REALTIME, &t2);
	clock_getres(CLOCK_REALTIME, &res);
	//long int elapsedTime = (t2.tv_usec - t1.tv_usec);

	printf("%ld.%.9ld, %ld.%.9ld, %ld.%.9ld\n", res.tv_sec, res.tv_nsec, t2.tv_sec, t2.tv_nsec, t1.tv_sec, t1.tv_nsec);

	t1 = t2;

	// protected region execute code end
}
\end{lstlisting}
\begin{lstlisting}[caption=Pcode::execute (improved), label=code:timer2, language=C++]
void Pcode::execute()
{
  // protected region execute code on begin
	static struct timespec t1;
	static uint64_t clockcycle;

	struct timespec t2;
	struct timespec res;
	uint64_t currentcycle = ClockCycles();

	clock_gettime(CLOCK_REALTIME, &t2);
	clock_getres(CLOCK_REALTIME, &res);
	int64_t dcycle= currentcycle-clockcycle;
	uint64_t cps = SYSPAGE_ENTRY(qtime)->cycles_per_sec;

	if(currentcycle > clockcycle)
		printf("%lld, %lld, %lld, %ld.%.9ld, %ld.%.9ld, %ld.%.9ld\n", currentcycle, clockcycle, cps, res.tv_sec, res.tv_nsec, t2.tv_sec, t2.tv_nsec, t1.tv_sec, t1.tv_nsec);

	t1 = t2;
	clockcycle = currentcycle;

	// protected region execute code end
}
\end{lstlisting}

\begin{figure}
 \centering
 \begin{subfigure}{\textwidth}
  \centering
  \includegraphics[width=0.8\textwidth]{./img/timer-mainmodel.png}
  \caption{Main model.}
 \end{subfigure}
 \begin{subfigure}{\textwidth}
  \centering
  \includegraphics[width=0.8\textwidth]{./img/timer-submodel.png}
  \caption{submodel}
 \end{subfigure}
 \caption{Model used for testing the timer}
 \label{fig:timermodel}
\end{figure}

\FloatBarrier
\subsection{Questions} \label{sec:1_4}
\begin{enumerate}
 \item Measured over $1522$ intervals, the variation is $3.667 \cdot 10^{-8}$ s$^2$ or $0.03667$ ms$^2$. Since the clock resolution of QNX in virtual box ($0.000999848$ s) is so much larger than the observed variation, our measurements are not accurate enough to result in a variation that is representative for the actual variation. With a clock resolution of $0.000999848$ s, and a timer that ticks every $0.250000000$ s without jitter, we expect $\lceil 0.25/0.000999848 \rceil - 0.25/0.000999848 = 96.2\%$ of the measurements to be $\lfloor 0.25/0.000999848 \rfloor \cdot 0.000999848 = 0.249962$ s, and the other $3.8\%$ to be $\lceil 0.25/0.000999848 \rceil \cdot 0.000999848 = 0.250962$ s. In $1522$ measurements we found $96.2\%$ of the intervals to be $0.249962$ s and $3.8\%$ $0.250962$ s. Therefore, our measurements do not provide evidence of jitter.
 
 Up to a jitter bounded by $0.250000 - 0.249962 = 0.00038$ s $= 380$ $\mu$s, we would still expect the same results. For larger jitter, we would expect to occasionally measure intervals of $0.248962$ s. So we can strengthen our claim: our measurements do not provide evidence of jitter larger than $380$ $\mu$s.
 
 We performed a second series of measurements, this time with the timer interval set to $0.249962$, an exact multiple of the clock resolution. We measured $1967$ intervals. With this configuration, we are likely to pick up on a variation larger than $(0.000999848/1967 \cdot 10^6)^2 \approx 0.258$ $\mu$s$^2$.
 
 Results of the second test is shown in figure~\ref{fig:interval-jitter}. This shows that there is indeed jitter. The variation of our measurements is $0.06$ ms$^2$.
 
 For a third test we used a method of timing with a resolution that is much higher: \texttt{ClockCycles()} from \texttt{sys/neutrino.h}. We can retrieve the number of clock cycles per second, so we can deduce how much time has passed from the number of clock cycles that have passed. We measured $3339$ intervals using this method. The distribution of intervals is shown in figure~\ref{fig:interval-jitter2}. We can clearly see how the jitter behaves. It is still distributed somewhat discretely, but smaller deviations are now clearly shown. In this test the variation of the measurements is $0.078$ ms$^2$.
 
 \item This jitter is the result of simulating a real time OS in an environment that is not real time. Since the host OS decided when the virtual OS can run, and the host OS cannot guarantee to meet real time requirements, the virtual OS is unable to meet those requirements either.
 
 \item We observe from figure~\ref{fig:interval-jitter} that the timer tick is occasionally delayed by more than $1$ ms. Such a delay is not acceptable in many real time applications. \todo{Example.}
 
 \item No. Our virtual machines run on a non real time OS (GNU/Linux), so it can happen that the host OS is very busy with tasks that have a higher priority than the virtual machines, postponing execution of the real time OS unboundedly, disabling QNX to meet its real time requirements.
 
\end{enumerate}

\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{./img/interval-jitter.png}
 \caption{Distribution of intervals in the second test.}
 \label{fig:interval-jitter}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{./img/interval-jitter2.png}
 \caption{Distribution of intervals in the third test.}
 \label{fig:interval-jitter2}
\end{figure}

\FloatBarrier
\subsection{Validation}
We further extended the code measuring the intervals to send an alternating signal to an output pin (see codeblock~\ref{code:timer3} \todo{and figure x}). The signal switches from high to low, or form low to high at each timer tick, producing a square wave of which we can measure the period using an oscilloscope.

\begin{lstlisting}[caption=Pcode::execute (extended), label=code:timer3, language=C++]
void Pcode::execute()
{
  // protected region execute code on begin
	static struct timespec t1;
	static uint64_t clockcycle;

	if (oc)
		oc = 0;
	else
		oc = 1;

	//printf("oc: %d\n", oc);

	struct timespec t2;
	struct timespec res;
	uint64_t currentcycle = ClockCycles();

	clock_gettime(CLOCK_REALTIME, &t2);
	clock_getres(CLOCK_REALTIME, &res);
	int64_t dcycle= currentcycle-clockcycle;
	uint64_t cps = SYSPAGE_ENTRY(qtime)->cycles_per_sec;

	if(currentcycle > clockcycle)
		printf("%lld, %lld, %lld, %ld.%.9ld, %ld.%.9ld, %ld.%.9ld\n", currentcycle, clockcycle, cps, res.tv_sec, res.tv_nsec, t2.tv_sec, t2.tv_nsec, t1.tv_sec, t1.tv_nsec);

	t1 = t2;
	clockcycle = currentcycle;

	// protected region execute code end
}
\end{lstlisting}

\subsection{Questions}
\begin{enumerate}
 \item Using the oscilloscope has the obvious disadvantages: it requires the availability of the oscilloscope, and an output pin. This output pin is not (easily) available for our dry-runs in a virtual machine. An additional disadvantage is that the supplied oscilloscope did not appear to have a function to measure a series of intervals easily. Only one measurement was shown on screen, updating frequently, making it very hard to generate a list of 1000-3000 measurements for an accurate assessment of the jitter like we did with the software method.
 
 The software method uses the same timing hardware to both produce the timer ticks, as to measure the intervals. This method only accurately measures the timer intervals, if the timing hardware is reliable.
 \item We ran two tests in the lab, one with a frequency of 4 Hz, and one with a frequency of 100 Hz. The readings from the oscilloscope seemed to agree with the measurements using the number of clockcycles, showing a period of 500.0 ms, sometimes 501.0 or 499.0 in the first run, and a period of 20.0 ms during the second run. We measured $758$ and $936$ intervals for 4 Hz and 100Hz respectively, using the number of clock cycles. Distribution of these measurements are shown in figure~\ref{fig:interval-jitter-rt} and figure~\ref{fig:interval-jitter-rt2}. Variation of these measurements are $0.053$ ms$^2$ and $0.0011$ ms$^2$ respectively. We see from the distribution that the test with 4 Hz resulted in two narrow peaks. We don't have an explanation for this \todo{(try to explain, or not)}, but clearly observe that the variation is a lot less than when using the virtual machine, more so than the actual variation of $0.053$ ms$^2$ would suggest.
 
 \item \todo{What theory?}
\end{enumerate}

\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{./img/interval-jitter-rt.png}
 \caption{Distribution of intervals in the lab, with the timer set to 4 Hz.}
 \label{fig:interval-jitter-rt}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{./img/interval-jitter-rt2.png}
 \caption{Distribution of intervals in the lab, with the timer set to 100 Hz.}
 \label{fig:interval-jitter-rt2}
\end{figure}

\FloatBarrier
\section{JIWYIO Linkdrivers}
\subsection{JIWYIO driver components}
We made the two models suggested in the exercise description.
\subsubsection{PWMTester}
We tested writing some values to the simulated port, first (codeblock~\ref{code:pwmex}).
After that we made a function to convert from int16$\_$t to uint16$\_$t by using bit-shift operations.
However, we later found that this convert function could be replaced by a simple 
cast from int16\_t to uint16\_t (codeblock~\ref{code:pwmcon}). \\
\todo{Reasoning normalize function.}
\begin{lstlisting}[caption=Pcode::execute, label=code:pwmex, language=C++]
void Pcode::execute()
{
  // protected region execute code on begin
	static double t = 1.0;

	//t = -32768; // fast reverse
	//t = 32767; // fast forward
	//t = 32768; // stop
	//t = -1000; // deadzone?

	//this->test = (uint16_t) t;

	this->test = convert(normalise(t));
	printf("%lf, %lf, %d \n", t, normalise(t), convert(normalise(t)));
	//t+= 6.28318;
	while(t>512)
		t-= 1024;

  // protected region execute code end
}
\end{lstlisting}
\begin{lstlisting}[caption=Pcode::convert, label=code:pwmcon, language=C++]
// protected region additional functions on begin
uint16_t Pcode::convert(double f)
{
	int16_t deadzone = 2200;

	int16_t n = f*(32768-deadzone);
	if(n>0)
		n += deadzone;
	else if(n<0)
		n -= deadzone;

	if(n>=0 && n<32768)
		return n;
	else if(n >= -32768 && n<0)
	{
		return (uint16_t)n;
	}
	else
		return 0;
}
\end{lstlisting}
\begin{lstlisting}[caption=Pcode::normalise, label=code:pwmnor, language=C++]
double Pcode::normalise(double n)
{
	// linear conversion assumed
	double min=-512, max=512;

	// normalise to [-1,1]
	n-= min;
	n/= max - min;
	n*= 2;
	n-= 1;

	return n;

	/*
	// scale to int16_t
	if(n=1)
		return 32767;
	else
		return n*32768;
	//*/
}
\end{lstlisting}
\subsubsection{EncoderTester}
The EncoderTester model merely prints values read from the port. We found out 
that converting from uint32\_t to int32\_t could be done by a simple cast. 
\begin{lstlisting}[caption=Relevant EncoderTester functions, label=code:enc, language=C++]
void Pcode::execute()
{
  // protected region execute code on begin
	printf("%d, %f - ", this->test, convert(this->test));
  // protected region execute code end
}

// protected region additional functions on begin
double Pcode::convert(uint32_t i)
{
	return (int32_t)i;
}
\end{lstlisting}

\subsection{Questions}
\begin{enumerate}
	\item The advantage of testing the link driver with a software simulation 
		allows us to run the program without requiring hardware.
		If in a project the hardware and software where to be developed 
		separately, this allows the software to be developed in parallel to the hardware.
		So, in this project, it allows us to make sure our program (reading/writing from a port) works correctly without being in the lab.
	\item One could attempt to make use of C++ sub-classing with a clear defined interface.
		This would mean one subclass for simulation and one for the actual hardware.
		This seems to be already implemented. The manual code changes could be solved by clever usage of regular expressions. The user interface is not really an issue here.
	\item The most obvious drawback is of course that you need to do the exact same edits every time you generate code from the models. Another drawback is that you have to adapt your code to run simulations for testing. It is not possible to test the actual code that will be run in the real environment.
\end{enumerate}

\subsection{JIWYIO driver components in the lab}
\todo{todo}

\subsection{Questions}
\begin{enumerate}
 \item \todo{todo}
 \item The 'first a dry-run and then testing in the lab'-approach is effective, because, it allows the software to be developed in parallel to the hardware.
	 This requires the interface to the hardware to be clearly defined.
	 \smallskip

	 One should take note that the dry-run software simulation is not a 
	 substitute for testing the code on real hardware.
	 The code might work in the simulation, but not on the real hardware.
\end{enumerate}

\newpage

\section{Controlling JIWY with QNX \& CSP}
Before the lab, we prepaired a TERRA project that contains the following functionality in submodels:
\begin{enumerate}
	\item Joystick input handling.
	\item JIWY model of Ex1 with TERRA-models of the provided 20sim models.
	\item IO output handling. Transforming double to int16\_t.
	\item Vertical and Horizonal encoding handling.
\end{enumerate}
See figure~\ref{fig:jiwy-overview}.
\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{./img/jiwy-overview.png}
 \caption{Top architecture model of the Ex2 JIWY model.}
 \label{fig:jiwy-overview}
\end{figure}
\subsection{Test at the lab}

\subsection{Questions}
\begin{enumerate}
 \item \todo{todo}
 \item \todo{todo}
\end{enumerate}

\subsection{Further functionality}
\todo{explain we didn't have time and it's not our fault}

\subsection{Questions}
\begin{enumerate}
 \item \todo{todo}
 \item \todo{todo}
 \item \todo{todo}
 \item \todo{todo}
\end{enumerate}

\end{document}
