/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  src\xxsim\PositionControllerTiltModel.cpp
 *  subm:  PositionControllerTiltModel
 *  model: PositionController2
 *  expmt: PositionController2
 *  date:  July 1, 2015
 *  time:  3:22:45 pm
 *  user:  Universiteit Twente 
 *  from:  20-sim 4.5 Campus Licentie
 *  build: 4.5.1.5561
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <cmath>

/* 20-sim include files */
#include "xxsim/PositionControllerTiltModel.hpp"

using namespace std;

namespace PositionControllerTilt
{

  PositionControllerTiltModel::PositionControllerTiltModel()
  {
    setupComputation();
  }

  PositionControllerTiltModel::~PositionControllerTiltModel(void)
  {
    /* delete IO mappings */
    while(!m_inputs.empty())
    {
      IAdapter20Sim* a = m_inputs.back();
      m_inputs.pop_back();
      delete a;
    }

    while(!m_outputs.empty())
    {
      IAdapter20Sim* a = m_outputs.back();
      m_outputs.pop_back();
      delete a;
    }

    /* free memory */
    delete[] C;
    delete[] P;
    delete[] I;
    delete[] V;
    delete[] s;
    delete[] R;
    delete[] M;
    delete[] U;
    delete[] workarray;
  }

  void PositionControllerTiltModel::setupComputation()
  {
    start_time = 0.0;
    finish_time = 0;
    step_size = 0.01;
    time = 0;
    major = true;

    number_constants = 0;
    number_parameters = 7;
    number_initialvalues = 3;
    number_variables = 12;
    number_states = 3;
    number_rates = 3;
    number_matrices = 0;
    number_unnamed = 0;

    /* the variable arrays */
    C = new XXDouble[0 + 1]; /* constants */
    P = new XXDouble[7 + 1]; /* parameters, currently only one type of parameter exists: double */
    I = new XXDouble[3 + 1]; /* initial values */
    V = new XXDouble[12 + 1]; /* variables */

    s = new XXDouble[3 + 1]; /* states */
    R = new XXDouble[3 + 1]; /* rates (or new states) */
    M = new XXMatrix[0 + 1]; /* matrices */
    U = new XXDouble[0 + 1]; /* unnamed */
    workarray = new XXDouble[0 + 1];
  }

  bool PositionControllerTiltModel::initializeComputation()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    initialize = true;
    //CONSTANTS
    

    //PARAMETERS
    	P[0] = 0.0;		/* corrGain\K */
	P[1] = 0.1;		/* PID1\kp */
	P[2] = 1.0;		/* PID1\tauD */
	P[3] = 0.1;		/* PID1\beta */
	P[4] = 1000.0;		/* PID1\tauI */
	P[5] = -0.99;		/* SignalLimiter2\minimum */
	P[6] = 0.99;		/* SignalLimiter2\maximum */


    //INITIAL VALUES
    	I[0] = 0.0;		/* PID1\uD_previous_initial */
	I[1] = 0.0;		/* PID1\error_previous_initial */
	I[2] = 0.0;		/* PID1\uI_previous_initial */


    //MATRICES
    

    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    //STATES - do NOT move this line up!
    	s[0] = I[0];		/* PID1\uD_previous */
	s[1] = I[1];		/* PID1\error_previous */
	s[2] = I[2];		/* PID1\uI_previous */


    /* end of initialization phase */
    initialize = false;
    return initialize;
  }

  void PositionControllerTiltModel::CopyInputsToVariables()
  {
    for(unsigned int i = 0; i < m_inputs.size(); ++i)
    {
      m_inputs[i]->copyVariableToXXVariable();
    }
  }

  void PositionControllerTiltModel::CopyVariablesToOutputs()
  {
    for(unsigned int i = 0; i < m_outputs.size(); ++i)
    {
      m_outputs[i]->copyXXVariableToVariable();
    }
  }

  void PositionControllerTiltModel::start()
  {
    initializeComputation();

    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void PositionControllerTiltModel::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
     and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void PositionControllerTiltModel::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  /* This function calculates the initial equations of the model.
   * These equations are calculated before anything else
   */
  inline void PositionControllerTiltModel::CalculateInitial (void)
  {
    
  }

  /* This function calculates the static equations of the model.
   * These equations are only dependent from parameters and constants
   */
  inline void PositionControllerTiltModel::CalculateStatic (void)
  {
    
  }

  /* This function calculates the input equations of the model.
   * These equations are dynamic equations that must not change
   * in calls from the integration method (like random and delay).
   */
  inline void PositionControllerTiltModel::CalculateInput (void)
  {
    
  }

  /* This function calculates the dynamic equations of the model.
   * These equations are called from the integration method
   * to calculate the new model rates (that are then integrated).
   */
  inline void PositionControllerTiltModel::CalculateDynamic (void)
  {
    	/* PID1\factor = 1 / (sampletime + PID1\tauD * PID1\beta); */
	V[3] = 1.0 / (step_size + P[2] * P[3]);

	/* corrGain\input = corr; */
	V[0] = V[9];

	/* PlusMinus2\plus1 = in; */
	V[5] = V[10];

	/* PlusMinus2\minus1 = position; */
	V[6] = V[11];

	/* corrGain\output = corrGain\K * corrGain\input; */
	V[1] = P[0] * V[0];

	/* PID1\error = PlusMinus2\plus1 - PlusMinus2\minus1; */
	R[1] = V[5] - V[6];

	/* PID1\uD = PID1\factor * (((PID1\tauD * PID1\uD_previous) * PID1\beta + (PID1\tauD * PID1\kp) * (PID1\error - PID1\error_previous)) + (sampletime * PID1\kp) * PID1\error); */
	R[0] = V[3] * (((P[2] * s[0]) * P[3] + (P[2] * P[1]) * (R[1] - s[1])) + (step_size * P[1]) * R[1]);

	/* PID1\uI = PID1\uI_previous + (sampletime * PID1\uD) / PID1\tauI; */
	R[2] = s[2] + (step_size * R[0]) / P[4];

	/* PID1\output = PID1\uI + PID1\uD; */
	V[2] = R[2] + R[0];

	/* PlusMinus1\output = corrGain\output + PID1\output; */
	V[4] = V[1] + V[2];

	/* SignalLimiter2\output = if PlusMinus1\output < SignalLimiter2\minimum... ; */
	V[7] = (V[4] < P[5]) ? 
		/* SignalLimiter2\minimum */
		P[5]
	:
		/* if PlusMinus1\output > SignalLimiter2\maximum...  */
		((V[4] > P[6]) ? 
			/* SignalLimiter2\maximum */
			P[6]
		:
			/* PlusMinus1\output */
			V[4]
		)
	;

	/* out = SignalLimiter2\output; */
	V[8] = V[7];

  }

  /* This function calculates the output equations of the model.
   * These equations are not needed for calculation of the rates
   * and are kept separate to make the dynamic set of equations smaller.
   * These dynamic equations are called often more than one time for each
   * integration step that is taken. This makes model computation much faster.
   */
  inline void PositionControllerTiltModel::CalculateOutput (void)
  {
    
      }

  /* This function calculates the final equations of the model.
   * These equations are calculated after all the calculations
   * are performed
   */
  inline void PositionControllerTiltModel::CalculateFinal (void)
  {
    
  }

}

